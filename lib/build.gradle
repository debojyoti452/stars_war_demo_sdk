plugins {
    id 'com.android.library'
    id 'org.jetbrains.kotlin.android'
    id 'maven-publish'
}

android {
    def globalConfiguration = rootProject.extensions.getByName("ext")

    compileSdk globalConfiguration["androidCompileSDK"]

    defaultConfig {
        minSdk globalConfiguration["androidMinSDK"]
        targetSdk globalConfiguration["androidCompileSDK"]

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    kotlinOptions {
        jvmTarget = '1.8'
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    flavorDimensions "default"

    productFlavors {
        develop {
            buildConfigField "String", 'STARWARS_BASE_URL', "\"" + getLocalPropertiesValue("starwars.dev.baseurl") + "\""
        }
    }
}

dependencies {
    def ext = rootProject.ext

    implementation(
            ext.libDependencies.kotlin,
            ext.libDependencies.kotlinKtx,
            ext.libDependencies.coroutines,
            ext.libDependencies.coroutinesAndroid,
            ext.libDependencies.timber,
            ext.libDependencies.gson,

            ext.libDependencies.retrofit,
            ext.libDependencies.retrofitConversion,
            ext.libDependencies.okHttp,
            ext.libDependencies.okHttpLoggingInterceptor,
            ext.libDependencies.retrofitCoroutinesAdapter,
    )

    testImplementation(
            ext.testDependencies.junit,
            ext.testDependencies.truth,
            ext.testDependencies.mockk,
    )
}

task androidJavadocs(type: Javadoc) {
    source = android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    android.libraryVariants.all { variant ->
        if (variant.name == 'release') {
            owner.classpath += variant.javaCompileProvider.get().classpath
        }
    }
    exclude '**/R.html', '**/R.*.html', '**/index.html'
}

task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
    archiveClassifier.set('javadoc')
    from androidJavadocs.destinationDir
}

task androidSourcesJar(type: Jar) {
    archiveClassifier.set('sources')
    from android.sourceSets.main.java.srcDirs
}

// Because the components are created only during the afterEvaluate phase, you must
// configure your publications using the afterEvaluate() lifecycle method.
project.afterEvaluate {
    publishing {
        publications {
            // Creates a Maven publication called "release".
            release(MavenPublication) {
                // Applies the component for the release build variant.
                from project(":lib").components.developRelease
//                println("Components: " + components*.name)
                // Adds javadocs and sources as separate jars.
                artifact androidJavadocsJar
                artifact androidSourcesJar

                // You can customize attributes of the publication here or in module's build.gradle file (if you save this as script and include it build.gradle file, then you can just replicate this whole block there only with changed fields).
                //groupId = 'com.example'
                //artifactId = 'custom-artifact'
                version = android.defaultConfig.versionName // or just '1.0'
            }
        }
    }
}

//afterEvaluate {
//    publishing {
//        publications {
//            release(MavenPublication) {
////                from components.release
//                groupId = 'com.example'
//                artifactId = 'lib'
//                version = 'v7'
//            }
//        }
//    }
//}

/**
 * get value from local.properties
 *
 * @return value of the key
 */
def getLocalPropertiesValue(key) {
    Properties properties = new Properties()
    properties.load(project.rootProject.file('local.properties').newDataInputStream())
    return properties.getProperty(key)
}
